<div class="highlight"><pre><span></span><span class="cm">/* Código feito para C99, compilado com GCC 14.2.1 com flags --std=c99 -O2 e --fast-math</span>
<span class="cm"> *</span>
<span class="cm"> * Hardware Original: TOSHIBA SATELLITE_C50-A PSCG6P-01YAR1, </span>
<span class="cm"> * CPU: Intel i5-3320M (4) @ 3.300GHz,</span>
<span class="cm"> * GPU: Intel 3rd Gen Core processor Graphics Controller</span>
<span class="cm"> * RAM: 7821MiB, SSD SATA3 1TB</span>
<span class="cm"> * </span>
<span class="cm"> * Aluno: Vasco Alves, 2022228207</span>
<span class="cm">*/</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdint.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;assert.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;time.h&gt;</span>

<span class="cp">#define RESIZE_FACTOR 1.61803</span>

<span class="cp">#define IDX_INVALID 4294967295</span>

<span class="cp">#define SEED 95911405</span>

<span class="cp">#define BLACK 0</span>
<span class="cp">#define RED 1</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx_t</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="kt">key_t</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">g_treesize</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">g_average</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">g_rotation_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">BinTreeNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">         </span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx_left</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx_right</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="n">BinTreeNode</span><span class="p">;</span><span class="w"> </span><span class="c1">// TOTAL = 12 Bytes per node;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">BinaryTree</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span>
<span class="w">    </span><span class="n">BinTreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="n">BinTree</span><span class="w"> </span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AVLNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">AVLNode</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AVLTree</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">AVLNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">tree_root</span><span class="p">;</span><span class="w"> </span><span class="c1">// rotations cause the root to change</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">AVLTree</span><span class="p">;</span><span class="w"> </span><span class="c1">// 20 bytes</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">RBNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w">     </span><span class="c1">// 4 bytes</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">right</span><span class="p">;</span><span class="w">    </span><span class="c1">// 4 bytes</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w">      </span><span class="c1">// 4 bytes</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w">   </span><span class="c1">// 1 bytes</span>
<span class="p">}</span><span class="w"> </span><span class="n">RBNode</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">RBTree</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">tree_root</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">RBTree</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">TreapNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">priority</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">TreapNode</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Treap</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TreapNode</span><span class="o">*</span><span class="w"> </span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">tree_root</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">elements</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Treap</span><span class="p">;</span>

<span class="cm">/* === HELPER FUNCTIONS === */</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">randint</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="nf">rand_idx</span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w">   </span><span class="nf">arr_gen_conj_a</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// ordem crescent, pouca repetição</span>
<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w">   </span><span class="nf">arr_gen_conj_b</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// ordem decrescent, pouca repetição</span>
<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w">   </span><span class="nf">arr_gen_conj_c</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// ordem aleatoria, pouca repetição</span>
<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w">   </span><span class="nf">arr_gen_conj_d</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// ordem aleatoria, 90% repetidos</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">arr_print</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="cm">/* ===== BINARY TREE ===== */</span>
<span class="k">extern</span><span class="w"> </span><span class="n">BinTree</span><span class="w">  </span><span class="nf">tree_binary_create</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">);</span><span class="w"> </span><span class="c1">// Creates binary tree with inicialized elements</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_binary_destroy</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">);</span><span class="w"> </span><span class="c1">// Frees binary tree</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_binary_resize</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">);</span><span class="w">  </span><span class="c1">// Resize binary tree</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_binary_insert</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span><span class="w"> </span><span class="c1">// insert key in binary tree, NO DUPLICATES</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_binary_insert_arr</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="w"> </span><span class="c1">// insert array of keys</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_binary_print_inorder</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">);</span><span class="w"> </span><span class="c1">// in order print according to tree</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_binary_print</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">);</span><span class="w">  </span><span class="c1">// print by levels for visual accuracy</span>
<span class="k">extern</span><span class="w"> </span><span class="n">idx_t</span><span class="w">    </span><span class="nf">tree_binary_search_key_inorder</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span><span class="w"> </span><span class="c1">// search for key in binary tree by order</span>
<span class="k">extern</span><span class="w"> </span><span class="n">idx_t</span><span class="w">    </span><span class="nf">tree_binary_search_key_level</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span><span class="w"> </span><span class="c1">// faster than inorder because of this structure</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">binary_test_and_log</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fptr</span><span class="p">);</span>

<span class="cm">/* ===== AVL TREE ===== */</span>
<span class="k">extern</span><span class="w"> </span><span class="n">AVLTree</span><span class="w"> </span><span class="nf">tree_avl_create</span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">inicial_capacity</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">    </span><span class="nf">tree_avl_destroy</span><span class="p">(</span><span class="n">AVLTree</span><span class="o">*</span><span class="w"> </span><span class="n">avl</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">    </span><span class="nf">tree_avl_resize</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w">      </span><span class="nf">_avl_get_height</span><span class="p">(</span><span class="n">AVLTree</span><span class="o">*</span><span class="w"> </span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w">      </span><span class="nf">_avl_get_balance</span><span class="p">(</span><span class="n">AVLTree</span><span class="o">*</span><span class="w"> </span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">    </span><span class="nf">_avl_rotate_right</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">y_index</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">    </span><span class="nf">_avl_rotate_left</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">x_index</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">    </span><span class="nf">_avl_insert_recursive</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">node_index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_avl_insert</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_avl_insert_arr</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="n">AVLNode</span><span class="o">*</span><span class="w"> </span><span class="nf">tree_avl_search</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">     </span><span class="nf">tree_avl_in_order</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">);</span><span class="w"> </span><span class="c1">// in-order print</span>

<span class="cm">/* ===== RED BLACK TREE ===== */</span>
<span class="k">extern</span><span class="w"> </span><span class="n">RBTree</span><span class="w">  </span><span class="nf">tree_rb_create</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">    </span><span class="nf">tree_rb_destroy</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">rb</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">    </span><span class="nf">tree_rb_resize</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">rb</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w">     </span><span class="nf">_rb_is_red</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">   </span><span class="nf">_rb_rotate_left</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">   </span><span class="nf">_rb_rotate_right</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w">    </span><span class="nf">_rb_flip_colors</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">   </span><span class="nf">_rb_fix_up</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w">   </span><span class="nf">_rb_insert_recursive</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">    </span><span class="nf">tree_rb_insert</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w">     </span><span class="nf">tree_rb_search</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">rb</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>

<span class="cm">/* ===== TREAP ===== */</span><span class="w"> </span>
<span class="k">extern</span><span class="w"> </span><span class="n">Treap</span><span class="w"> </span><span class="nf">tree_treap_create</span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">  </span><span class="nf">tree_treap_resize</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">  </span><span class="nf">tree_treap_destroy</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="nf">_treap_rotate_right</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">x_idx</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="nf">_treap_rotate_left</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">x_idx</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="nf">_treap_insert_recursive</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w">  </span><span class="nf">tree_treap_insert</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>

<span class="cm">/* ==== FUNCTION DECLATRATIONS ==== */</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span>
<span class="nf">randint</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">;</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">rng_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SEED</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">rand_idx</span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rng_state</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">rng_state</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span>
<span class="w">    </span><span class="n">rng_state</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">rng_state</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span>
<span class="w">    </span><span class="n">rng_state</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">rng_state</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">rng_state</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">max</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span>
<span class="nf">arr_gen_conj_a</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">key_t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">key_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// não podes saltar um item atrás de 0</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new_arr</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span>

<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span>
<span class="nf">arr_gen_conj_b</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">key_t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">key_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// não podes saltar um item atrás de 0</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="n">offset</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new_arr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span>
<span class="nf">arr_gen_conj_c</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* Array crescente com repetição minima */</span>
<span class="w">    </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr_gen_conj_a</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Knuth Shuffle */</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new_arr</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span>

<span class="k">static</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span>
<span class="nf">arr_gen_conj_d</span><span class="p">(</span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">new_arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">key_t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">new_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// não podes saltar um item atrás de idx 0</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Knuth Shuffle */</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">new_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">new_arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new_arr</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">arr_print</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;arr[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="p">}</span>


<span class="n">BinTree</span>
<span class="nf">tree_binary_create</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">initial_capacity</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">};</span>
<span class="w">    </span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="p">)</span><span class="o">*</span><span class="n">initial_capacity</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">nodeptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">endptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodeptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">;</span><span class="w"> </span><span class="n">nodeptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">endptr</span><span class="p">;</span><span class="w"> </span><span class="n">nodeptr</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">nodeptr</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">nodeptr</span><span class="o">-&gt;</span><span class="n">idx_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">nodeptr</span><span class="o">-&gt;</span><span class="n">idx_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">btree</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_binary_destroy</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_binary_resize</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="o">*</span><span class="n">RESIZE_FACTOR</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* In case of overflow */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_capacity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">new_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">tries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">new_root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">tries</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">new_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">BinTreeNode</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="p">)</span><span class="o">*</span><span class="n">new_capacity</span><span class="p">);</span>
<span class="w">        </span><span class="n">tries</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Failed to allocate enough memory for tree resize.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_root</span><span class="p">;</span>
<span class="w">    </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_binary_insert</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* NA OPERAÇÃO DE INSERÇÃO QUANDO UMA CHAVE JÁ EXISTIR, NÃO É CRIADA NOVA CHAVE */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IDX_INVALID</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">tree_binary_search_key_level</span><span class="p">(</span><span class="o">*</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/*puts(&quot;capacity exceeded&quot;);*/</span>
<span class="w">        </span><span class="cm">/*printf(&quot;capacity = %d\n&quot;, btree-&gt;capacity);*/</span>
<span class="w">        </span><span class="n">tree_binary_resize</span><span class="p">(</span><span class="n">btree</span><span class="p">);</span>
<span class="w">        </span><span class="cm">/*printf(&quot;new capacity = %d\n&quot;, btree-&gt;capacity);*/</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">inicial_elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Está vazia */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inicial_elements</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Devido às propriedades das àrvores binárias implicitas,</span>
<span class="cm">         * o indice corresponde ao número de elementos-1,</span>
<span class="cm">         * como é o próximo indice, -1+1 = 0 */</span>
<span class="w">        </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">root</span><span class="p">[</span><span class="n">inicial_elements</span><span class="p">];</span>
<span class="w">        </span><span class="cm">/* O pai do NOVO filho está em (Nº Elementos+1) / 2 arredondado para baixo -1 para o indice</span>
<span class="cm">         * O que pode ser simplificado para simplesmente o numero de elements&gt;&gt;1 </span>
<span class="cm">         * O módulo diz-nos se é para a esquerda ou direita */</span>
<span class="w">        </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">parent_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">root</span><span class="p">[</span><span class="n">inicial_elements</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inicial_elements</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">idx_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inicial_elements</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">idx_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inicial_elements</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Inserir nova chave  */</span>
<span class="w">    </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inicial_elements</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_binary_insert_arr</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tree_binary_insert</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_binary_print_inorder</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* Helper function to print the entire binary tree */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">inorder</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="w">        </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">inorder</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">idx_left</span><span class="p">);</span>
<span class="w">        </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">        </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">inorder</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">idx_right</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;In-order traversal of the binary tree:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">inorder</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">idx_left</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">inorder</span><span class="p">(</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">idx_right</span><span class="p">);</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_binary_print</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="o">*</span><span class="n">btree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">levels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n_elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Contar niveis */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n_elem</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">n_elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_elem</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">levels</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">BinTreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%2d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Imprimir cada nivel */</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">levels</span><span class="p">;</span><span class="w"> </span><span class="n">l</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* Cada nivel tem o dobro dos elementos no maximo  */</span>
<span class="w">        </span><span class="n">n_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_nodes</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n_nodes</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">btree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%2d  &quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="o">+</span><span class="n">idx</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="p">);</span>
<span class="w">            </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="p">}</span>

<span class="n">idx_t</span>
<span class="nf">tree_binary_search_key_inorder</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/*Helper function */</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">tree_binary_search</span><span class="p">(</span><span class="n">BinTreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span><span class="w"> </span>

<span class="w">        </span><span class="n">BinTreeNode</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w"> </span>

<span class="w">        </span><span class="n">idx_t</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_binary_search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">idx_left</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="p">;</span><span class="w"> </span>

<span class="w">        </span><span class="n">idx_t</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_binary_search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">idx_right</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">right</span><span class="p">;</span><span class="w"> </span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">BinTreeNode</span><span class="o">*</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_binary_search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">idx_left</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>

<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_binary_search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="o">-&gt;</span><span class="n">idx_right</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>

<span class="n">idx_t</span>
<span class="nf">tree_binary_search_key_level</span><span class="p">(</span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* Como não existe ordem inerente nesta àrvore binária, os nós estão</span>
<span class="cm">     * inseridos no array da esquerda para a direita, logo posso percorrer o array.</span>
<span class="cm">     * Vou optimizar porque sim. */</span>

<span class="w">    </span><span class="k">register</span><span class="w"> </span><span class="n">BinTreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="p">;</span>
<span class="w">    </span><span class="k">register</span><span class="w"> </span><span class="n">BinTreeNode</span><span class="w"> </span><span class="o">*</span><span class="n">ptr_back</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">btree</span><span class="p">.</span><span class="n">root</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">btree</span><span class="p">.</span><span class="n">elements</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*printf(&quot;Search key = %d\n&quot;, key);*/</span>

<span class="w">    </span><span class="k">register</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ptr_back</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>

<span class="w">        </span><span class="cm">/* prefetch */</span>
<span class="w">        </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">__builtin_prefetch</span><span class="p">(</span><span class="n">ptr_back</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Unrolling */</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_front</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_back</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">ptr_back</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">ptr_back</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">((</span><span class="n">ptr_back</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>

<span class="w">        </span><span class="n">ptr_front</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr_back</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">found</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* elementos restante */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_front</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">ptr_back</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">found</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_front</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_back</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">ptr_front</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr_back</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">found</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">binary_test_and_log</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">BinTree</span><span class="w"> </span><span class="n">btree</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g_average</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="n">btree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_binary_create</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">        </span><span class="n">tree_binary_insert_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btree</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">        </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>

<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
<span class="w">        </span><span class="n">tree_binary_destroy</span><span class="p">(</span><span class="n">btree</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">total</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Binary Tree = %0.4lfms</span><span class="se">\t</span><span class="s">(0 rotations)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">total_time</span><span class="o">/</span><span class="n">g_average</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">AVLTree</span>
<span class="nf">tree_avl_create</span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">inicial_capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">inicial_capacity</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">AVLTree</span><span class="w"> </span><span class="n">avl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">inicial_capacity</span><span class="p">};</span>
<span class="w">    </span><span class="n">avl</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AVLNode</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">AVLNode</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">inicial_capacity</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avl</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t allocate AVL tree.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inicial_capacity</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="p">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AVLNode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">IDX_INVALID</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">avl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_avl_destroy</span><span class="p">(</span><span class="n">AVLTree</span><span class="o">*</span><span class="w"> </span><span class="n">avl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">avl</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_avl_resize</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="o">*</span><span class="n">RESIZE_FACTOR</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_capacity</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;AVL tree exceeded maximum capacity.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">AVLNode</span><span class="o">*</span><span class="w"> </span><span class="n">new_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AVLNode</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">AVLNode</span><span class="p">)</span><span class="o">*</span><span class="n">new_capacity</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_nodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to allocate enough memory for tree resize.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_nodes</span><span class="p">;</span><span class="w">        </span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">_avl_get_height</span><span class="p">(</span><span class="n">AVLTree</span><span class="o">*</span><span class="w"> </span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">_avl_get_balance</span><span class="p">(</span><span class="n">AVLTree</span><span class="o">*</span><span class="w"> </span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_avl_rotate_right</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">node_idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Perform rotation:</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node_idx</span><span class="p">;</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Update heights:</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">left</span><span class="p">),</span><span class="w"> </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_idx</span><span class="p">].</span><span class="n">right</span><span class="p">));</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">left</span><span class="p">),</span><span class="w"> </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">right</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_avl_rotate_left</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">x_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">x_index</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Perform rotation:</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_index</span><span class="p">;</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">x_index</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T2</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Update heights:</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">x_index</span><span class="p">].</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">x_index</span><span class="p">].</span><span class="n">left</span><span class="p">),</span><span class="w"> </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">x_index</span><span class="p">].</span><span class="n">right</span><span class="p">));</span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">left</span><span class="p">),</span><span class="w"> </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">right</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_avl_insert_recursive</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">node_index</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node_index</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">idx_t</span><span class="w"> </span><span class="n">new_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">;</span>
<span class="w">        </span><span class="n">AVLNode</span><span class="o">*</span><span class="w"> </span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">new_index</span><span class="p">];</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">        </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">new_index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="cm">/* Binary Search Tree */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_insert_recursive</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_insert_recursive</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">node_index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="p">),</span>
<span class="w">                                             </span><span class="n">_avl_get_height</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Get balance factor to check if rebalancing is needed.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_get_balance</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Left Left */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">balance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_avl_rotate_right</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Right Right */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">balance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_avl_rotate_left</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Left Right */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">balance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_rotate_left</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">left</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_avl_rotate_right</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Right Left */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">balance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_rotate_right</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_index</span><span class="p">].</span><span class="n">right</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_avl_rotate_left</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">node_index</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">node_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_avl_insert</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">elements</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tree_avl_resize</span><span class="p">(</span><span class="n">avl</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="cm">/* For an empty tree, set the new node as root. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">elements</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_insert_recursive</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_avl_insert_recursive</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span>
<span class="nf">tree_avl_in_order</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">_traverse</span><span class="p">(</span><span class="n">AVLNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="n">AVLNode</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">_traverse</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
<span class="w">        </span><span class="n">_traverse</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">_traverse</span><span class="p">(</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">);</span>
<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_avl_in_order_non</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">AVLNode</span><span class="w"> </span><span class="n">current_node</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">current_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">];</span>

<span class="w">        </span><span class="cm">/* Traverse left sub-tree until leaf */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current_node</span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_node</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current_node</span><span class="p">.</span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="n">AVLNode</span><span class="o">*</span>
<span class="nf">tree_avl_search</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_index</span><span class="p">].</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_index</span><span class="p">];</span>
<span class="w">            </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_index</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_index</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>

<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">current_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">avl</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">current_index</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">  </span><span class="c1">// Key not found.</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="nf">tree_avl_insert_arr</span><span class="p">(</span><span class="n">AVLTree</span><span class="w"> </span><span class="o">*</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">avl</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">endptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">+</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">endptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="n">arr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tree_avl_insert</span><span class="p">(</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="nf">avl_test_and_log</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">AVLTree</span><span class="w"> </span><span class="n">avl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Reset global rotation counter */</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g_average</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="n">avl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_avl_create</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="w">        </span><span class="n">tree_avl_insert_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avl</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">        </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>

<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
<span class="w">        </span><span class="n">tree_avl_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">avl</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">total</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;AVL Tree = %0.4lfms</span><span class="se">\t</span><span class="s">(%d rotations)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">total_time</span><span class="o">/</span><span class="n">g_average</span><span class="p">,</span><span class="w"> </span><span class="n">g_rotation_count</span><span class="o">/</span><span class="n">g_average</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Red Black Tree Implementation */</span>
<span class="cm">/* Criar arvore */</span>
<span class="n">RBTree</span>
<span class="nf">tree_rb_create</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RBTree</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">initial_capacity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">RBNode</span><span class="p">));</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// a raiz da arvore é invalida inicialmente</span>
<span class="w">    </span><span class="c1">// para que seja pintada correctamente de preto (caso especial)</span>
<span class="w">    </span><span class="c1">// e inserida imediatamente</span>
<span class="w">    </span><span class="n">tree</span><span class="p">.</span><span class="n">tree_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>

<span class="w">    </span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">endptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="n">nodes</span><span class="o">+</span><span class="n">tree</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">endptr</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Destruir árvore */</span>
<span class="kt">void</span>
<span class="nf">tree_rb_destroy</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">rb</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">rb</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Aumentar capacidade */</span>
<span class="kt">void</span>
<span class="nf">tree_rb_resize</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">tree</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">RESIZE_FACTOR</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">new_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">RBNode</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_nodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to allocate more nodes.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// inicializar novos nós</span>
<span class="w">    </span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">endptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_nodes</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_nodes</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">endptr</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">        </span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* 1 (verdadeiro) se o nó for vermelho */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">_rb_is_red</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// a raiz da arvore é invalida inicialmente</span>
<span class="w">    </span><span class="c1">// isto significa que vai ser pintada correctamente de preto</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* rotação à esquerda */</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_rb_rotate_left</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* rotação à direita */</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_rb_rotate_right</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">pivot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pivot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Inverter cores */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">_rb_flip_colors</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">left</span><span class="p">].</span><span class="n">color</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">right</span><span class="p">].</span><span class="n">color</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Resolve comflictos */</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_rb_fix_up</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Caso 1: direita vermelha e esquerda preta -&gt; rotação à esquerda */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_rb_is_red</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">_rb_is_red</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">))</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_rb_rotate_left</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Caso 2: filho esquerdo vermelho e neto esquerdo vermelho -&gt; rotação à direita */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_rb_is_red</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_rb_is_red</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">].</span><span class="n">left</span><span class="p">))</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_rb_rotate_right</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Caso 3: ambos os filhos são vermelhos */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">_rb_is_red</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">_rb_is_red</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="p">))</span>
<span class="w">        </span><span class="n">_rb_flip_colors</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Inserção recursiva: Devolve o novo indice da raiz se inserir */</span>
<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_rb_insert_recursive</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* Inserir após encontrar nova folha </span>
<span class="cm">     * (chamada anterior para filho que não existe) */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">idx_t</span><span class="w"> </span><span class="n">new_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">;</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">new_index</span><span class="p">].</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">new_index</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">new_index</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">new_index</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RED</span><span class="p">;</span><span class="w">  </span><span class="c1">// sempre vermelho</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">new_index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="cm">/* Recursão equivalente a binary search tree */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_rb_insert_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_rb_insert_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">h</span><span class="p">].</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* É necessário corrigir erros causados pela inserção */</span>
<span class="w">    </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_rb_fix_up</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Inserir nó */</span>
<span class="kt">void</span>
<span class="nf">tree_rb_insert</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="cm">/* Aumentar capacidade  se for necessário */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">)</span>
<span class="w">        </span><span class="n">tree_rb_resize</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>

<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_rb_insert_recursive</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">].</span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BLACK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pesquisa */</span>
<span class="kt">int</span>
<span class="nf">tree_rb_search</span><span class="p">(</span><span class="n">RBTree</span><span class="w"> </span><span class="o">*</span><span class="n">tree</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RBNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* binary search tree search */</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;current = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">key</span><span class="p">)</span>
<span class="w">            </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">current</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span>
<span class="nf">rb_test_and_log</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">RBTree</span><span class="w"> </span><span class="n">vp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Reset global rotation counter */</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g_average</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="n">vp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_rb_create</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g_treesize</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">tree_rb_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
<span class="w">        </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>

<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
<span class="w">        </span><span class="n">tree_rb_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">total</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;RB Tree = %0.4lfms</span><span class="se">\t</span><span class="s">(%d rotations)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">total_time</span><span class="o">/</span><span class="n">g_average</span><span class="p">,</span><span class="w"> </span><span class="n">g_rotation_count</span><span class="o">/</span><span class="n">g_average</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Treap Functions */</span>
<span class="n">Treap</span>
<span class="nf">tree_treap_create</span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Treap</span><span class="w"> </span><span class="n">new_treap</span><span class="p">;</span>
<span class="w">    </span><span class="n">new_treap</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TreapNode</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TreapNode</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_treap</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to allocate Treap.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">new_treap</span><span class="p">.</span><span class="n">tree_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">;</span>
<span class="w">    </span><span class="n">new_treap</span><span class="p">.</span><span class="n">elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">new_treap</span><span class="p">.</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* inicializar novos nós */</span>
<span class="w">    </span><span class="n">TreapNode</span><span class="o">*</span><span class="w"> </span><span class="n">endptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_treap</span><span class="p">.</span><span class="n">nodes</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">initial_capacity</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">TreapNode</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_treap</span><span class="p">.</span><span class="n">nodes</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">endptr</span><span class="p">;</span><span class="w"> </span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TreapNode</span><span class="p">){</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new_treap</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">tree_treap_resize</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* se a capacity for máxima */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">old_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">idx_t</span><span class="p">)(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">RESIZE_FACTOR</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* se a nova capacity for maior que a capacidade máxima */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_capacity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">new_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">TreapNode</span><span class="w"> </span><span class="o">*</span><span class="n">new_nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TreapNode</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">realloc</span><span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">TreapNode</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_nodes</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">perror</span><span class="p">(</span><span class="s">&quot;Failed to realloc new nodes.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_nodes</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* incializar nova memóra */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_capacity</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TreapNode</span><span class="p">){</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">};</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_capacity</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_treap_destroy</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
<span class="w">    </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_treap_rotate_right</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">no_idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="n">TreapNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">pivot_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">no_idx</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* à esquerda agora fica a subtree do pivot */</span><span class="w"> </span>
<span class="w">    </span><span class="n">nodes</span><span class="p">[</span><span class="n">no_idx</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* à direita do pivot fica o nó atual */</span><span class="w"> </span>
<span class="w">    </span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">no_idx</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* o pivot não muda de sitio mas pode passar a ser a nova raiz */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pivot_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span>
<span class="nf">_treap_rotate_left</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">no_idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="o">++</span><span class="p">;</span>

<span class="w">    </span><span class="n">TreapNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span>
<span class="w">    </span><span class="n">idx_t</span><span class="w"> </span><span class="n">pivot_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">no_idx</span><span class="p">].</span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* subtree do pivot */</span><span class="w"> </span>
<span class="w">    </span><span class="n">nodes</span><span class="p">[</span><span class="n">no_idx</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">].</span><span class="n">left</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* o pivot agora leva ao nó */</span><span class="w"> </span>
<span class="w">    </span><span class="n">nodes</span><span class="p">[</span><span class="n">pivot_idx</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">no_idx</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* o pivot pode passar a ser a nova raiz */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pivot_idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="n">idx_t</span>
<span class="nf">_treap_insert_recursive</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TreapNode</span><span class="w"> </span><span class="o">*</span><span class="n">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Criamos um novo nó quando quando o idx é inválido,</span>
<span class="cm">     * ou seja, quando o BST tenta inserir numa folha</span>
<span class="cm">     * depois devolvemos o novo indice à chamada anterior desta função*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">idx_t</span><span class="w"> </span><span class="n">new_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">;</span>
<span class="w">        </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TreapNode</span><span class="p">){</span>
<span class="w">            </span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">,</span>
<span class="w">            </span><span class="p">.</span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">idx_t</span><span class="p">)</span><span class="n">rand_idx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>
<span class="w">            </span><span class="p">.</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">,</span>
<span class="w">            </span><span class="p">.</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IDX_INVALID</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">new_index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* inserir tipo binary search tree */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_treap_insert_recursive</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* manter max heap */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">left</span><span class="p">].</span><span class="n">priority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">priority</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_treap_rotate_right</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_treap_insert_recursive</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* manter max heap */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">right</span><span class="p">].</span><span class="n">priority</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">nodes</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">priority</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_treap_rotate_left</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* inserir nó */</span>
<span class="kt">void</span>
<span class="nf">tree_treap_insert</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="kt">key_t</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">)</span><span class="w">    </span>
<span class="w">        </span><span class="n">tree_treap_resize</span><span class="p">(</span><span class="n">treap</span><span class="p">);</span>

<span class="w">    </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_treap_insert_recursive</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tree_treap_visualize</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">is_left</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="n">TreapNode</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">root</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Print current node</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">depth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">is_left</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;├── &quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;└── &quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;(%d, p=%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Prepare prefix for child nodes</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">new_prefix</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="w">    </span><span class="n">snprintf</span><span class="p">(</span><span class="n">new_prefix</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_prefix</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;%s%s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">depth</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">is_left</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;│   &quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;    &quot;</span><span class="p">));</span>

<span class="w">    </span><span class="c1">// Right child (printed first for better tree shape)</span>
<span class="w">    </span><span class="n">tree_treap_visualize</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">new_prefix</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Left child</span>
<span class="w">    </span><span class="n">tree_treap_visualize</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">new_prefix</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">treap_test_and_log</span><span class="p">(</span><span class="kt">key_t</span><span class="o">*</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="w"> </span><span class="o">*</span><span class="n">fptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">Treap</span><span class="w"> </span><span class="n">treap</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">clock_t</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Reset global rotation counter */</span>
<span class="w">    </span><span class="n">g_rotation_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>


<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>
<span class="w">        </span><span class="n">treap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tree_treap_create</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">idx_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g_treesize</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">tree_treap_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
<span class="w">        </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clock</span><span class="p">();</span>

<span class="w">        </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">);</span>
<span class="w">        </span><span class="n">tree_treap_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">treap</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">total_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="w"> </span><span class="n">total</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">fptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TREAP = %0.4lfms</span><span class="se">\t</span><span class="s">(%d rotations)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">total_time</span><span class="o">/</span><span class="n">g_average</span><span class="p">,</span><span class="w"> </span><span class="n">g_rotation_count</span><span class="o">/</span><span class="n">g_average</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">tree_treap_inorder_print</span><span class="p">(</span><span class="n">Treap</span><span class="w"> </span><span class="o">*</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">idx_t</span><span class="w"> </span><span class="n">root</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">root</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IDX_INVALID</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="n">tree_treap_inorder_print</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">left</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">key</span><span class="p">);</span>
<span class="w">    </span><span class="n">tree_treap_inorder_print</span><span class="p">(</span><span class="n">treap</span><span class="p">,</span><span class="w"> </span><span class="n">treap</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;aed-prej2 [treesize] [average]&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">g_treesize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">g_average</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_treesize</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Invalid tree size.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_average</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Invalid average.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">srand</span><span class="p">(</span><span class="n">SEED</span><span class="p">);</span>

<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="o">*</span><span class="n">conjunto_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr_gen_conj_a</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="o">*</span><span class="n">conjunto_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr_gen_conj_b</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="o">*</span><span class="n">conjunto_c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr_gen_conj_c</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>
<span class="w">    </span><span class="kt">key_t</span><span class="w"> </span><span class="o">*</span><span class="n">conjunto_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr_gen_conj_d</span><span class="p">(</span><span class="n">g_treesize</span><span class="p">);</span>

<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">filelog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="s">&quot;log.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;a&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">filelog</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">=== NEW LOG === (Treesize = %d, Average = &amp;d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">g_treesize</span><span class="p">,</span><span class="w"> </span><span class="n">g_average</span><span class="p">);</span>

<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Testing binary search tree...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">binary_test_and_log</span><span class="p">(</span><span class="n">conjunto_a</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">binary_test_and_log</span><span class="p">(</span><span class="n">conjunto_b</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">binary_test_and_log</span><span class="p">(</span><span class="n">conjunto_c</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">binary_test_and_log</span><span class="p">(</span><span class="n">conjunto_d</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>

<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Testing AVL tree...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">avl_test_and_log</span><span class="p">(</span><span class="n">conjunto_a</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">avl_test_and_log</span><span class="p">(</span><span class="n">conjunto_b</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">avl_test_and_log</span><span class="p">(</span><span class="n">conjunto_c</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">avl_test_and_log</span><span class="p">(</span><span class="n">conjunto_d</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>

<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Testing Red-Black tree...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">rb_test_and_log</span><span class="p">(</span><span class="n">conjunto_a</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">rb_test_and_log</span><span class="p">(</span><span class="n">conjunto_b</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">rb_test_and_log</span><span class="p">(</span><span class="n">conjunto_c</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">rb_test_and_log</span><span class="p">(</span><span class="n">conjunto_d</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>

<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Testing RB search tree...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">treap_test_and_log</span><span class="p">(</span><span class="n">conjunto_a</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">treap_test_and_log</span><span class="p">(</span><span class="n">conjunto_b</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">treap_test_and_log</span><span class="p">(</span><span class="n">conjunto_c</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>
<span class="w">    </span><span class="n">treap_test_and_log</span><span class="p">(</span><span class="n">conjunto_d</span><span class="p">,</span><span class="w"> </span><span class="n">filelog</span><span class="p">);</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">conjunto_a</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">conjunto_b</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">conjunto_c</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">conjunto_d</span><span class="p">);</span>

<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">filelog</span><span class="p">);</span>

<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;Done!&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;notify-send -u critical done&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
